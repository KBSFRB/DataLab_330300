<!DOCTYPE html>
<html lang="en">
<head>
	<base target="_top">
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>3-30-300</title>
	
	<link rel="shortcut icon" type="image/x-icon" href="docs/images/favicon.ico" />

	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
	<link rel="stylesheet" href="style/geosearch.css"/>
	<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
	<script src="https://cdn.tailwindcss.com"></script>
	<script src="https://unpkg.com/leaflet-geosearch@latest/dist/bundle.min.js"></script>
	<script src="scripts/utils.js"></script>
	<script src="scripts/layers_handling.js"></script>


	<style>
		html, body {
			height: 100%;
			margin: 0;
		}
	</style>

	
</head>
<body>
	<div class="popup" onclick="myFunction()">Click me!
		<span class="popuptext" id="myPopup">Popup text...</span>
	  </div>


<div id="map" class="w-full h-full"></div>

<div class="absolute bottom-4 left-4 z-[100000]">
	<form class="bg-white/75 border rounded py-2 px-3 border-black hidden sm:block" id="mode_menu">
		<fieldset>
			<legend>Scoring</legend>
			<div>
				<input type="radio" name="scoring" value="overall" checked id="scoring_overall">
				<label for="scoring_overall">Overall</label>
			</div>
			<div>
				<input type="radio" name="scoring" value="rule3" id="scoring_rule3">
				<label for="scoring_rule3">Rule 3: Trees</label>
			</div>
			<div>
				<input type="radio" name="scoring" value="rule30" id="scoring_rule30">
				<label for="scoring_rule30">Rule 30: canopy cover</label>
			</div>
			<div>
				<input type="radio" name="scoring" value="rule300" id="scoring_rule300">
				<label for="scoring_rule300">Rule 300: access to parks</label>
			</div>
		</fieldset>
	</form>
	<div class="sm:hidden bg-white/75 border rounded py-2 px-3 border-black inline-block mt-2 cursor-pointer"
		onclick="document.getElementById('mode_menu').classList.toggle('hidden')"
	>
		<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="inline-block" viewBox="0 0 16 16">
		  <path d="m14.12 10.163 1.715.858c.22.11.22.424 0 .534L8.267 15.34a.6.6 0 0 1-.534 0L.165 11.555a.299.299 0 0 1 0-.534l1.716-.858 5.317 2.659c.505.252 1.1.252 1.604 0l5.317-2.66zM7.733.063a.6.6 0 0 1 .534 0l7.568 3.784a.3.3 0 0 1 0 .535L8.267 8.165a.6.6 0 0 1-.534 0L.165 4.382a.299.299 0 0 1 0-.535z"/>
		  <path d="m14.12 6.576 1.715.858c.22.11.22.424 0 .534l-7.568 3.784a.6.6 0 0 1-.534 0L.165 7.968a.299.299 0 0 1 0-.534l1.716-.858 5.317 2.659c.505.252 1.1.252 1.604 0z"/>
		</svg>
	</div>
</div>

<script>

	let scoring_mode = document.querySelector('input[name="scoring"]:checked').value;
	const init_zoom = 8;
	const min_building_zoom = 15;
	const colors_scheme = ['#a6611a','#dfc27d','#80cdc1','#018571'];
	
	/* Create the base map */
	
	const map = L.map('map', {
		renderer: L.canvas(),
		minZoom: 7
	}).setView([50.6, 4.4], init_zoom);
	
	var CartoDB_Positron = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
		attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
		maxZoom: 19,
	}).addTo(map);

	/* Force user inside of bounds */
	const southWest = L.latLng(49.5, 2.4),
	northEast = L.latLng(51.7, 6.6);
	const bounds = L.latLngBounds(southWest, northEast);

	map.setMaxBounds(bounds);
	map.on('drag', function() {
	    map.panInsideBounds(bounds, { animate: false });
	});

	/* Add the search bar */
	const search = new GeoSearch.GeoSearchControl({
	  provider: new GeoSearch.OpenStreetMapProvider({
	    params: {
	      countrycodes: 'be'
	    }
	  }),
	  style: 'bar',
	});

	map.addControl(search);

	/* Add the legend */

	let legend = L.control({position: 'bottomright'});

	legend.onAdd = function () {
	    this._div = L.DomUtil.create('div', 'bg-white/75 border rounded py-2 px-3 border-black');
	    this.update();
    	return this._div;
	};

	legend.update = function(mode=scoring_mode) {

		let zoom = map.getZoom();

		let grades = [];

		if (zoom < min_building_zoom) {
			// compute grades by splitting the range 0-1 into n equal parts, where n is the number of colors in the color scheme
			if (mode == 'overall') {
				grades = Array.from({length: colors_scheme.length+1}, (_, i) => i / colors_scheme.length * 3);
				this._div.innerHTML = '<p>Average number of rules satisfied</p>'
				for (let i = 0; i < grades.length-1; i++) {
			        this._div.innerHTML +=
			            '<span class="inline-block w-3 h-3" style="background:' + get_color(colors_scheme, (grades[i] + grades[i+1])/2/3) + '"></span> ' +
			            grades[i] + '&ndash;' + grades[i + 1] + '<br>';
			    }
			} else {
		    	grades = Array.from({length: colors_scheme.length+1}, (_, i) => i / colors_scheme.length);

		    	this._div.innerHTML = `<p>Percentage of buildings satisfying ${mode}</p>`
		    	for (let i = 0; i < grades.length-1; i++) {
			        this._div.innerHTML +=
			            '<span class="inline-block w-3 h-3" style="background:' + get_color(colors_scheme, (grades[i] + grades[i+1])/2) + '"></span> ' +
			            format_percent(grades[i]) + '&ndash;' + format_percent(grades[i + 1]) + '<br>';
			    }
			}

		} else {

			if (mode == 'overall') {
				grades = [0, 1, 2, 3];
				this._div.innerHTML = '<p>Number of rules satisfied</p>'
				for (let i = 0; i < grades.length; i++) {
			        this._div.innerHTML +=
			            '<span class="inline-block w-3 h-3" style="background:' + get_color(colors_scheme, grades[i]/3) + '"></span> ' +
			            grades[i] + '<br>';
			    }
			} else {
				this._div.innerHTML = `
					<p>Is ${mode} satisfied?</p>
					<span class="inline-block w-3 h-3" style="background:${get_color(colors_scheme, 0)}"></span> No<br>
					<span class="inline-block w-3 h-3" style="background:${get_color(colors_scheme, 1)}"></span> Yes<br>
				`
			}
			
		}

	    return this._div;
	}



	legend.addTo(map);



	

	function rule3(f) {
		const p = f.properties;
		if (p.rule3_perc_buildings || p.rule3_perc_buildings === 0) {
			return p.rule3_perc_buildings;
		} else if (p.rule3) {
			return p.rule3 == 1 || p.rule3 == 'True' ? 1 : 0;
		} else if (p.r3) {
			return p.r3 == 1 || p.r3 == 'True' ? 1 : 0;
		} else {
			return 0;
		}
	}
	function rule30(f) {
		const p = f.properties;
		if (p.rule30_perc_buildings || p.rule30_perc_buildings === 0) {
			return p.rule30_perc_buildings;
		} else if (p.rule30) {
			return p.rule30 == 1 || p.rule30 == 'True' ? 1 : 0;
		} else if (p.r30) {
			return p.r30 == 1 || p.r30 == 'True' ? 1 : 0;
		} else {
			return 0;
		}
	}
	function rule300(f) {
		const p = f.properties;
		if (p.rule300_perc_buildings || p.rule300_perc_buildings === 0) {
			return p.rule300_perc_buildings;
		} else if (p.rule300) {
			return p.rule300 == 1 || p.rule300 == 'True' ? 1 : 0;
		} else if (p.r300) {
			return p.r300 == 1 || p.r300 == 'True' ? 1 : 0;
		} else {
			return 0;
		}
	}

	function make_area_popup_text(level) {
		function area_name(f) {
			let lang = 'NL';
			if (navigator.language.startsWith('fr')) {
				lang = 'FR';
			} else if (navigator.language.startsWith('de')) {
				lang = 'DE';
			}
			
			return f.properties[`T_${level}_${lang}`];
		}

		return function(f) {
			return `${area_name(f)}<br>
					At least 3 trees: ${format_percent(rule3(f))} of buildings<br>
					At least 30% canopy: ${format_percent(rule30(f))} of buildings<br>
					Public green space less than 300m away: ${format_percent(rule300(f))} of buildings<br>
					Average score: ${format_score(rule3(f) + rule30(f) + rule300(f))} / 3`;
		}
	}

	function score(f) {
		switch (scoring_mode) {
			case 'rule3':
				return rule3(f);
			case 'rule30':
				return rule30(f);
			case 'rule300':
				return rule300(f);
			default:
				// Turns out this is equivalent to computing the average score of all buildings in the area
				return (rule3(f) + rule30(f) + rule300(f))/3;
		}

	}

	/* Layers' description */

	const layers = [
		{
			name: 'buildings', min_zoom: min_building_zoom, tiling: true, 
			extent: {min_y: 49.499671, min_x: 2.554748, max_y: 51.505145, max_x: 6.407739}, grid_size: 100, 
			url: (i, j) => `https://pub-4b0dc5689db344d8b9ea341d605c0bff.r2.dev/chopped_buildings/buildings_${i}_${j}.geojson`,
			popup_text: f => `
				At least 3 trees: ${(rule3(f)) ? 'Yes' : 'No'}<br>
				At least 30% canopy: ${(rule30(f)) ? 'Yes' : 'No'}<br>
				Public green space less than 300m away: ${(rule300(f)) ? 'Yes' : 'No'}<br>
				Score: ${rule3(f) + rule30(f) + rule300(f)}/3
			`,
			score: score,
		},
		{
			name: 'statistical_sectors', min_zoom: 12, tiling: true, 
			"extent": {"min_x": 2.541329, "max_x": 6.4081, "min_y": 49.496956, "max_y": 51.505113}, "grid_size": 10, 
			url: (i, j) => `https://pub-4b0dc5689db344d8b9ea341d605c0bff.r2.dev/chopped_sectors/tile_${i}_${j}.geojson`,
			popup_text: make_area_popup_text('SEC'), score: score, data_id: 'sector_nis',
		},
		{
			name: 'municipalities', min_zoom: 10, tiling: true, 
			"extent": {"min_x": 2.541329, "max_x": 6.4081, "min_y": 49.496955, "max_y": 51.505113}, "grid_size": 5, 
			url: (i, j) => `https://pub-4b0dc5689db344d8b9ea341d605c0bff.r2.dev/chopped_mun/tile_${i}_${j}.geojson`,
			popup_text: make_area_popup_text('MUN'), score: score, data_id: 'mun_nis',
		},
		// {
		// 	name: 'arrondissements', min_zoom: 9, tiling: false,
		// 	url: () => 'https://pub-4b0dc5689db344d8b9ea341d605c0bff.r2.dev/arr_3_30_300.geojson',
		// 	popup_text: make_area_popup_text('ARRD'),
		// },
		{
			name: 'provinces', min_zoom: 8, tiling: false,
			url: () => 'https://pub-4b0dc5689db344d8b9ea341d605c0bff.r2.dev/prov_3_30_300.geojson',
			popup_text: make_area_popup_text('PROVI'), score: score, data_id: 'prov_nis',
		},
		{
			name: 'regions', min_zoom: 0, tiling: false,
			url: () => 'https://pub-4b0dc5689db344d8b9ea341d605c0bff.r2.dev/reg_3_30_300.geojson',
			popup_text: make_area_popup_text('REGIO'), score: score, data_id: 'reg_nis',
		}
	];

	// Create the layers
	initialize_layers(layers);
	

	// Initialise the map
	update_map();

	/* Event listeners: control when map is updated */
	// 1. When we move thourgh the map
	map.on('moveend', update_map);
	// 2. When we zoom in or out
	map.on('zoomend', () => {update_map(); legend.update()});

	function repaint() {
		for (let layer of layers) {
			layer.layer.resetStyle();
		}
	}

	// 3. When we change the scoring mode
	document.querySelectorAll('input[name="scoring"]').forEach((radio) => {
    radio.addEventListener('change', () => {scoring_mode = radio.value; repaint(); legend.update()});

  });

</script>




</body>
</html>